---
description: 設計完了後からタスク分解・実装・品質保証まで実施
---
**コマンドコンテキスト**: 実装サイクル管理（タスク分解→実装→品質保証）

ultrathink

## 初回必須タスク

作業開始前に以下のルールファイルを必ず読み込み、厳守してください：
- @.claude/steering/core-principles.md - 全エージェント共通原則（タスク管理、品質基準、エラー対応）
- @.claude/steering/sub-agents.md - サブエージェント管理フロー

## 入力形式

```
/design-to-implementation <ストーリーURL or ストーリーディレクトリ> [追加指示]
```

**引数**：
- `<ストーリーURL or ストーリーディレクトリ>` (必須):
  - NotionストーリーページのURL、または
  - ストーリーディレクトリパス（例: `specs/stories/TC-S-0001-database-schema-prisma`）
- `[追加指示]` (任意): ユーザーからの追加要望・制約・方針

## コマンドの前提条件

このコマンドは**設計フェーズが完了している**ことを前提とします：

### 必須の事前準備
✅ requirements.md（要件定義書）が存在
✅ ADR（アーキテクチャ決定記録）が存在
✅ design.md（技術設計書）が存在
✅ plan.md（作業計画書）が存在

### 前提となるコマンド
通常、以下のコマンドの後に実行します：
- `/stories-to-design` - ストーリーから設計・計画まで実施済み

## コマンドの目的

このコマンドは**設計完了後から実装完了まで**を実施します：

### 実施範囲
✅ タスク分解（task-decomposer）- tasks/配下のタスクファイル生成
✅ タスク実装（task-executor）- 各タスクを順次実行
✅ 品質保証（quality-fixer）- プロジェクト全体品質チェック
✅ コードレビュー（code-reviewer）- 実装完全性検証
✅ PR作成・Notion同期（実装レビュータスク作成、ステータス更新）

### 実施範囲外
❌ 要件分析（requirement-analyzer）- 設計フェーズで完了済み
❌ 技術設計（technical-designer）- 設計フェーズで完了済み
❌ 作業計画（work-planner）- 設計フェーズで完了済み

### 使用シーン
- `/stories-to-design` で設計レビューを受けた後、実装を開始したい
- 設計ドキュメントが既に存在し、実装のみを実施したい
- 実装をやり直す（設計は変更せず、実装のみ再実行）

## 実行判断フロー

### 1. ストーリー特定とディレクトリ確認
指示内容: $ARGUMENTS

**Step 1: ストーリー特定**
- ストーリーURLが指定された場合:
  - meta.jsonを読み込み、notion_story_idを取得
  - ストーリーディレクトリパスを特定（例: `specs/stories/TC-S-0001-xxx`）
- ストーリーディレクトリパスが指定された場合:
  - そのパスを使用

**Step 2: 事前条件チェック**
ストーリーディレクトリ内に以下のファイルが存在することを確認：
- [ ] requirements.md
- [ ] specs/adr/XXX.md（ADR）
- [ ] design.md
- [ ] plan.md

いずれかが欠けている場合：
- エラーメッセージを表示
- `/stories-to-design <ストーリーURL>` の実行を促す
- 処理を中断

### 2. 現在状況の判定
指示内容: $ARGUMENTS

| 状況パターン | 判定基準 | 次のアクション |
|------------|---------|-------------|
| 新規実装開始 | tasks/ディレクトリが存在しない | task-decomposerから開始 |
| 実装継続 | tasks/ディレクトリが存在、一部タスク完了 | 未完了タスクから再開 |
| 実装やり直し | tasks/ディレクトリが存在、全タスク完了 | ユーザーに確認後、task-executorから再実行 |

### 3. 次のアクション実行

**sub-agents.mdを必ず参照**：
- 規模別フロー（大規模/中規模/小規模）を確認
- 自律実行モードの条件を確認
- タスク実行後の品質サイクルを理解
- フローに定義された次のサブエージェントを呼び出す

## 📋 sub-agents.md準拠の実行

**実行前チェック（必須）**：
- [ ] sub-agents.mdの該当フローを確認した
- [ ] 現在の進捗位置を特定した（タスク分解→実装フェーズ）
- [ ] 次のステップを明確にした
- [ ] タスク実行後の品質サイクルを理解した

**フロー逸脱禁止**: sub-agents.mdに定義されたフローから外れることは禁止。

## 🎯 オーケストレーターとしての必須責務

### タスク実行時の品質サイクル管理
**絶対的ルール**：task-executor実行後は必ず以下を実行
1. git commit実行（Bashツール使用）
2. 次タスクの実行または完了報告

**省略禁止**：このサイクルを省略した場合、実装品質を保証できない

### 実装完了条件
以下がすべて揃った時点で完了：
1. ✅ すべてのタスクが完了している（task-executor）
2. ✅ プロジェクト全体の品質チェックが完了している（quality-fixer）
3. ✅ コードレビューが完了している（code-reviewer）
4. ✅ PRが作成されている
5. ✅ Notionに実装レビュータスクが作成されている
6. ✅ Notionストーリーステータスが「実装レビュー待ち」に更新されている
7. ✅ meta.jsonにPR情報が記録されている

## 責務境界

**本コマンドの責務**: オーケストレーターとしてサブエージェントを適切に振り分け、実装サイクルを管理
**責務外**:
- 設計ドキュメントの作成・修正
- 自身での実装作業、調査作業（Grep/Glob/Read等）

---

## 実装専門原則（オーケストレーター・実装エージェント向け）

### 🚨 最重要原則：調査OK、実装STOP

**すべてのEdit/Write/MultiEditツール使用前にユーザー承認が必須**

理由：ユーザーの意図と異なる実装を防ぎ、正しい方向性を確保するため

### 実装実行プロセス

#### 実行フロー（必須手順）
1. **TodoWriteでタスク分解** → なければ実装ステップに進めない
2. **Edit/Write/MultiEdit使用** → ユーザー承認が必須
3. **実装実行** → 品質チェックエラーは完了条件を満たさない
4. **ファイル数カウント** → 閾値超過で自動停止

#### TodoWriteと実装の統合
**実行ルール**：
- TodoWriteなしでEditツール使用: ルール違反として停止
  理由：タスク管理なしでは進捗追跡と品質保証ができないため

#### 実装前提条件
1. **TodoWriteのタスク** → in_progressステータスが存在すること
2. **ユーザー承認記録** → Edit/Write前に明示的承認があること
3. **品質チェック結果** → エラー0でなければ完了不可

#### 禁止事項（実装時）
- **TodoWriteなしのEdit使用** → ルール違反
- **承認なしEdit/Write/MultiEdit** → 承認待ちに移行
- **品質エラー残存での完了宣言** → 完了条件を満たさない

### 実装時の行動制御（失敗防止）

#### 自動停止トリガー（必ず停止）
- **5ファイル以上の変更検出**：即座停止、影響範囲をユーザーに報告
  理由：大規模変更は事前計画とレビューが必要なため
- **3ファイル編集完了**: TodoWriteの更新を強制（更新しないと次のEditツール使用不可）
  理由：進捗確認と方向性の再確認が必要なため

#### エラー修正衝動対処
1. エラー発見 → **一時停止**
2. 根本原因分析（なぜ？を5回繰り返して真因を特定）
3. 対処計画提示
4. ユーザー承認後に修正

#### 集中時のルール無視防止
**測定可能な強制停止基準**：
- **連続エラー修正2回目**: 一時停止し、根本原因分析を実施
- **Editツール5回使用**: 影響範囲レポートの作成を強制
- **同一ファイル3回編集**: リファクタリング検討の強制停止

### 品質チェックの責務分担

#### 各タスク実行時
task-executorがtasksファイルの完了条件に従って基本品質チェック実行：
- TypeScript strict mode: エラー0件
- Biome lint: エラー0件
- 追加したテスト: すべてパス

#### 最終タスク実行時
quality-fixerがプロジェクト全体品質チェック実行：
- オーケストレーターが最終Phaseの最終タスクで呼び出し
- プロジェクト全体の統合品質を保証

## 同期ポイント（CHECKPOINT）

### CHECKPOINT: 実装完了時（唯一の同期ポイント）

**タイミング**: 最終task-executor完了後、quality-fixer実行後、code-reviewer実行後

**実行内容**:
1. git commit実行:
   - すべての実装変更をコミット
   - コミットメッセージにストーリーIDを含める

2. PRレビュー（UI実装の場合）:
   - ui-fixer実行（Figmaデザインとの一致性検証）
   - visual-checker実行（視覚的差異分析）

3. PR作成:
   - gh pr create でPR作成
   - タイトル: ストーリータイトル
   - 本文: 実装内容、テスト結果、変更ファイル数

4. notion-client(create_review_task)を呼び出し:
   - reviewType: implementation
   - storyId: {STORY_ID}
   - data: 実装情報（PRリンク、変更ファイル数、テスト結果）

5. notion-client(update_story_status)を呼び出し:
   - storyId: {STORY_ID}
   - status: 実装レビュー待ち

6. meta.jsonを更新:
   - github_pr_url: PRのURL
   - github_branch: ブランチ名

7. 完了報告をユーザーに提示:
   - PR URL
   - 変更ファイル数
   - テスト結果
   - 次のステップ（実装レビュー待ち）

**目的**: 実装フェーズ完了をNotionに記録し、レビュータスクを作成

## 実行フロー（詳細）

### Phase 1: タスク分解
1. **plan.md確認**
   - 作業計画書から実装フェーズを読み取る
   - 各フェーズの作業内容を確認

2. **task-decomposer実行**
   - 入力: plan.md
   - 出力: tasks/配下のタスクファイル（task-001.md, task-002.md, ...）

3. **タスク情報の確認**
   - タスク総数
   - 各タスクの推定工数
   - タスク間の依存関係

### Phase 2: タスク実装
1. **各タスク実行**（task-executor）
   - tasks/task-001.md から順次実行
   - 各タスク完了後にgit commit
   - 品質チェック（TypeScript、Lint、Test）を実施

2. **進捗管理**
   - TodoWriteでタスク進捗を管理
   - 1タスク完了ごとにステータス更新

3. **エラー対応**
   - エラー発生時は一時停止
   - 根本原因分析
   - 対処計画提示後、ユーザー承認を得て修正

### Phase 3: 品質保証
1. **quality-fixer実行**
   - プロジェクト全体の品質チェック
   - TypeScript strict mode: エラー0件
   - Biome lint: エラー0件
   - すべてのテスト: パス
   - ビルド: 成功

2. **code-reviewer実行**
   - design.mdの受入条件との照合
   - 実装漏れの検出
   - 品質レポート生成

3. **UI実装の場合（追加）**
   - ui-fixer実行（Figmaデザインとの一致性検証）
   - visual-checker実行（視覚的差異分析）

### Phase 4: PR作成・Notion同期
1. **PR作成**
   - gh pr create でPR作成
   - タイトル: ストーリータイトル
   - 本文: 実装内容、テスト結果、変更ファイル数

2. **notion-client(create_review_task)**
   - 実装レビュータスクを作成

3. **notion-client(update_story_status)**
   - ストーリーステータスを「実装レビュー待ち」に更新

4. **meta.json更新**
   - github_pr_url、github_branchを記録

5. **完了報告**
   ```
   ✅ 実装フェーズ完了

   ## 実装内容
   - タスク総数: N件（すべて完了）
   - 変更ファイル数: X件
   - テスト結果: すべてパス

   ## PR情報
   - PR URL: https://github.com/xxx/pull/123
   - ブランチ: feature/xxx

   ## 次のステップ
   1. 実装レビューを受ける（Notionでレビュータスク作成済み）
   2. レビュー承認後、mainブランチにマージ
   ```

## 品質基準

### 必須条件
- [ ] すべてのタスクが完了している
- [ ] TypeScript strict mode: エラー0件
- [ ] Biome lint: エラー0件
- [ ] すべてのテスト: パス
- [ ] ビルド: 成功
- [ ] code-reviewer: 受入条件すべて満たす
- [ ] PRが作成されている
- [ ] Notionに実装レビュータスクが作成されている
- [ ] Notionストーリーステータスが更新されている
- [ ] meta.jsonにPR情報が記録されている

### 推奨条件
- [ ] コードカバレッジ: 70%以上
- [ ] E2Eテスト: すべてパス
- [ ] UI実装の場合: Figmaデザインとの一致性確認

## エラーハンドリング

### 事前条件チェック失敗
- requirements.md、ADR、design.md、plan.mdのいずれかが存在しない
- 対処: エラーメッセージを表示、`/stories-to-design` の実行を促す

### タスク実行エラー
- task-executorがエラー
- 対処: エラー内容を分析、根本原因を特定、対処計画を提示

### 品質チェック失敗
- quality-fixerがエラー
- 対処: エラー内容を修正、再度quality-fixerを実行

### PR作成失敗
- gh pr createがエラー
- 対処: エラーメッセージを確認、手動でPR作成を促す

### Notion同期失敗
- notion-client(create_review_task)またはupdate_story_statusがエラー
- 対処: エラーメッセージを提示、手動でNotionを更新するよう促す

## 制約事項

### このコマンドで実施しないこと
1. **要件分析**（requirement-analyzer）- 設計フェーズで完了済み
2. **技術設計**（technical-designer）- 設計フェーズで完了済み
3. **作業計画**（work-planner）- 設計フェーズで完了済み

### 設計変更が必要な場合
実装中に設計変更が必要になった場合：
- 一時停止
- 設計変更の提案
- ユーザー承認後、design.md、plan.mdを更新
- 必要に応じて `/stories-to-design` から再実行

## 使用例

```bash
# 例1: ストーリーURLで指定
/design-to-implementation https://www.notion.so/2adaebc7449b8114a0b0c41faa16485b

# 例2: ストーリーディレクトリパスで指定
/design-to-implementation specs/stories/TC-S-0001-database-schema-prisma

# 例3: 追加指示付き
/design-to-implementation specs/stories/TC-S-0002-parent-auth-system "パフォーマンス重視で実装"
```

## まとめ

`/design-to-implementation`コマンドは、設計完了後からタスク分解・実装・品質保証・PR作成までを自動化します。

**利点**：
- 設計レビュー後にスムーズに実装開始できる
- タスク管理と品質保証が自動化される
- Notion同期が自動化され、進捗管理が容易

**前提条件**：
- `/stories-to-design` で設計フェーズが完了していること
- ストーリーディレクトリ内に requirements.md、ADR、design.md、plan.mdが存在すること

**次のステップ**：
- 実装レビューを受ける
- レビュー承認後、mainブランチにマージ
