---
id: "5"
feature: monitoring-logging-healthcheck
type: adr
version: 1.0.0
created: 2025-11-22
based_on: N/A
---

# ADR 011: ヘルスチェックHTTPサーバー実装方式

## ステータス

Accepted

## コンテキスト

Dify使用量エクスポーターにヘルスチェック機能を追加する必要がある。Kubernetes/ECS等のオーケストレーション環境でのLiveness/Readiness Probeとして使用され、コンテナの死活監視に活用される。

### 技術選定における主要な判断ポイント

1. **軽量性**: CLIアプリケーションの本体に影響を与えない最小限のリソース使用
2. **依存関係**: 追加ライブラリの有無とメンテナンスコスト
3. **メンテナンス性**: コードの複雑性と将来の拡張性
4. **既存コードとの整合性**: プロジェクトの技術スタックとの一貫性

### 要件

- ヘルスチェックポート: 8080（デフォルト、環境変数で変更可能）
- エンドポイント: `GET /health`
- レスポンス: 200 OKのみ（シンプルなJSON形式）
- 既存処理への影響最小化

## 決定事項

**Node.js標準httpモジュールを採用する。**

- **HTTPサーバー**: Node.js標準 `http.createServer()`
- **追加依存**: なし
- **エンドポイント**: `/health` のみ
- **レスポンス形式**: JSON（uptime, status, timestamp）

## 根拠

### 検討した選択肢

#### 1. Node.js標準httpモジュール（採用）

- **説明**: Node.js組み込みのhttpモジュールで最小限のHTTPサーバーを実装
- **利点**:
  - **依存関係ゼロ**: 追加ライブラリ不要、パッケージサイズに影響なし
  - **最軽量**: メモリ使用量・CPU使用量が最小（Expressの約半分のメモリ使用量）
  - **ネイティブ性能**: Expressの約2-4倍のリクエスト処理性能（2024-2025年ベンチマーク）
  - **シンプルな実装**: 単一エンドポイントであれば20-30行で完結
  - **既存コードとの整合性**: プロジェクトは外部フレームワーク非依存
  - **起動時間が短い**: 追加モジュール読み込みが不要
- **欠点**:
  - ルーティング、ミドルウェアは手動実装
  - 複数エンドポイント追加時はコードが冗長になる
  - 型安全性はaxiosほど高くない（ただしヘルスチェックでは問題なし）

#### 2. Express

- **説明**: Node.jsの定番Webフレームワーク
- **利点**:
  - 豊富なミドルウェアエコシステム
  - シンプルなAPIで記述が容易
  - 大規模なコミュニティとドキュメント
  - 馴染みのある開発者が多い
- **欠点**:
  - **依存関係の追加**: express + 依存ライブラリ（30+パッケージ）
  - **パフォーマンス**: 標準httpモジュールの約1/2〜1/4の速度（2024-2025年ベンチマーク）
  - **メモリ使用量**: 標準httpモジュールの約2倍
  - **オーバースペック**: 単一エンドポイントに対して機能過多
  - **プロジェクト整合性**: 本プロジェクトはHTTP API提供が主目的ではない

#### 3. Fastify

- **説明**: 高性能を謳うモダンなWebフレームワーク
- **利点**:
  - 標準httpモジュールに近い高性能（約4.5倍Express比）
  - プラグインアーキテクチャで拡張性が高い
  - TypeScript完全対応
  - 組み込みのバリデーション機能
- **欠点**:
  - **依存関係の追加**: fastify + 依存ライブラリ
  - **学習コスト**: 独自のプラグインシステムの理解が必要
  - **オーバースペック**: 単一エンドポイントに対して機能過多
  - **プロジェクト整合性**: 本プロジェクトはCLIツールであり、Webフレームワーク不要

#### 4. Hapi

- **説明**: 設定駆動型のWebフレームワーク
- **利点**:
  - エンタープライズ向けの堅牢性
  - 組み込みの入力検証とキャッシュ
  - 設定ベースで一貫性が高い
- **欠点**:
  - **最も重い依存関係**: 多数のパッケージに依存
  - **学習コスト高**: 設定ベースの独自アプローチ
  - **明らかにオーバースペック**: ヘルスチェックには不適切

### 選択理由

**Node.js標準httpモジュールを選択した理由:**

1. **最軽量性（最優先）**
   - ヘルスチェックは頻繁に呼び出されるが、処理内容は極めて単純
   - 追加依存ゼロでパッケージサイズ・起動時間に影響なし
   - メモリフットプリント最小化でコンテナリソース効率向上

2. **プロジェクトの性質との整合性**
   - 本プロジェクトはCLIバッチ処理ツールであり、Web APIサーバーではない
   - 既存コードはフレームワーク非依存（axios以外の外部HTTP関連依存なし）
   - 単一エンドポイントのみで将来の拡張予定なし

3. **シンプルな要件**
   - `GET /health` への200 OKレスポンスのみ
   - ルーティング不要、ミドルウェア不要
   - 認証・バリデーション不要

4. **ネイティブ性能**
   - ベンチマーク上、標準httpは最高性能（Expressの約2-4倍、メモリ使用量は約半分）
   - ヘルスチェックは高頻度で呼び出されるため性能は重要

5. **保守性**
   - Node.js標準APIは安定しており、破壊的変更リスクが低い
   - 外部ライブラリのバージョンアップ対応が不要

### トレードオフの受容

**受け入れるトレードオフ:**

- ルーティングは手動実装
  - **軽減策**: 単一エンドポイントのみなのでif文1つで十分
  - **判断**: 複雑なルーティングは不要なため問題なし

- 将来エンドポイント追加時のスケーラビリティ
  - **軽減策**: 将来必要になればその時点でリファクタリング（YAGNI原則）
  - **判断**: 現時点では`/health`のみが要件であり、過剰な拡張性は不要

- Express/Fastifyと比較した開発体験
  - **軽減策**: コード量は20-30行程度で十分管理可能
  - **判断**: 開発体験より軽量性と整合性を優先

## 影響

### ポジティブな影響

- **依存関係の最小化**: 追加ライブラリなしでセキュリティリスク低減
- **最高性能**: ネイティブHTTPサーバーによる最速レスポンス
- **リソース効率**: コンテナのメモリ・CPU使用量最小化
- **保守性向上**: 外部依存のバージョンアップ対応不要
- **起動時間短縮**: 追加モジュール読み込みなし
- **プロジェクト整合性**: フレームワーク非依存を維持

### ネガティブな影響

- **手動実装**: ルーティング、エラーハンドリングを自前で実装
- **拡張性制限**: 複数エンドポイント追加時はリファクタリングが必要

### 中立的な影響

- **学習曲線**: Node.js標準APIは広く知られており学習コストは低い

## 実装への指針

### 原則

1. **単一エンドポイント**
   - `/health` への GET リクエストのみ処理
   - 他のパス・メソッドは404を返す

2. **レスポンス形式**
   ```json
   {
     "status": "ok",
     "uptime": 12345.678,
     "timestamp": "2025-01-22T10:30:00.000Z"
   }
   ```

3. **エラーハンドリング**
   - サーバー起動失敗時は明確なエラーログを出力
   - ポート使用中の場合は適切なエラーメッセージを表示

4. **Graceful Shutdown対応**
   - 既存のGraceful Shutdownハンドラーに統合
   - SIGINT/SIGTERM時にserver.close()を呼び出し

5. **環境変数での設定**
   - `HEALTHCHECK_PORT`: ヘルスチェックポート（デフォルト8080）
   - `HEALTHCHECK_ENABLED`: 有効/無効の切り替え（デフォルトtrue）

6. **構造化ログ出力**
   - サーバー起動時にポート番号をログ出力
   - リクエスト処理はログ出力しない（高頻度のため）

7. **非同期起動**
   - メインプロセスのブロックを避けるため非同期で起動
   - 起動完了をPromiseで通知

## 参考資料

- [How to implement a health check in Node.js - LogRocket Blog](https://blog.logrocket.com/how-to-implement-a-health-check-in-node-js/): 実装パターン
- [Node.js Health Check Best Practices - Stack Overflow](https://stackoverflow.com/questions/48885862/nodejs-application-healthcheck-best-practice): ベストプラクティス
- [Express vs Fastify Performance - BetterStack](https://betterstack.com/community/guides/scaling-nodejs/fastify-express/): フレームワーク比較
- [Fastify Benchmarks](https://fastify.dev/benchmarks/): 性能比較データ
- [Observability: Node.js Health Check Example](https://koalatea.io/node-js-health-check/): 実装例

## 関連情報

- ADR 008: バックエンド基盤技術スタック（技術選定の背景）
- specs/stories/5-monitoring-logging-healthcheck/design.md: Design Doc
