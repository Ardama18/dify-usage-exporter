---
id: 4
feature: external-api-sender
type: adr
version: 1.0.0
created: 2025-11-18
based_on: specs/stories/4-external-api-sender/prd.md
---

# ADR 003: ファイルロック機構

## ステータス

Accepted

## コンテキスト

スプールファイルを複数プロセスが同時にアクセスする可能性がある場合、ファイル競合を防ぐためのロック機構が必要になる。以下の2つのシナリオを考慮する必要がある：

1. **水平スケール**: 複数のプロセスが並行してスプールファイルを読み書きする
2. **単一プロセス**: スケジューラが1プロセスのみを起動し、順次実行する

現在の要件では、シンプル性を優先し、YAGNI原則に基づいて過剰設計を避ける必要がある。

## 決定事項

**単一プロセス前提（ファイルロック機構不要）を採用する。**

- **プロセス数**: スケジューラ（node-cron）が1プロセスのみを起動
- **ファイルロック**: 実装しない
- **将来の拡張**: 分散実行が必要になった場合、DynamoDBやRedisなどの外部ストレージを導入

## 根拠

### 検討した選択肢

#### 1. 単一プロセス前提（ファイルロック不要）（採用）
- **説明**: スケジューラが1プロセスのみを起動し、ファイルロック機構を実装しない
- **利点**:
  - 実装が非常にシンプル（ロック処理不要）
  - ファイルシステムのみで完結（外部依存なし）
  - デバッグが容易（競合状態のトラブルシューティング不要）
  - パフォーマンスオーバーヘッドなし（ロック待機時間ゼロ）
  - YAGNI原則に適合（現在の要件では不要な機能を実装しない）
- **欠点**:
  - 水平スケールができない（1プロセスのみ）
  - 複数プロセス起動時にファイル競合のリスク（ただし、設計上起こり得ない）
  - 将来的に分散実行が必要になった場合、大幅な再設計が必要

#### 2. ファイルベースロック（flock、lockfile）
- **説明**: ファイルシステムのロック機構を使用（Node.jsの`proper-lockfile`等）
- **利点**:
  - ファイルシステムのみで完結（外部依存なし）
  - 複数プロセス対応が可能
  - 実装コストが比較的低い（ライブラリ使用）
- **欠点**:
  - ファイルシステムの種類によって挙動が異なる（NFSでは動作しない場合がある）
  - ロック解放漏れのリスク（プロセスクラッシュ時）
  - デッドロックのリスク（複数ファイルのロック順序管理が必要）
  - パフォーマンスオーバーヘッド（ロック取得・解放の待機時間）
  - 実装の複雑性（エラーハンドリング、タイムアウト処理）

#### 3. 分散ロック（DynamoDB、Redis）
- **説明**: 外部ストレージを使用した分散ロック（DynamoDB Conditional Writes、Redis SETNX）
- **利点**:
  - 真の分散環境で動作（複数サーバー間でロック共有）
  - ファイルシステムの制約を受けない
  - ロック解放の確実性が高い（TTL設定可能）
  - 水平スケールに完全対応
- **欠点**:
  - 外部依存の追加（DynamoDB/Redis必須）
  - 実装が最も複雑（接続管理、エラーハンドリング、TTL設定）
  - インフラコストの増加（DynamoDB/Redisの運用コスト）
  - ネットワーク依存（外部ストレージへの接続が必須）
  - 現在の要件に対してオーバーエンジニアリング

### 選択理由

**単一プロセス前提を選択した理由:**

1. **シンプル性優先（YAGNI原則）**
   - 現在の要件では単一プロセスで十分（スケジューラが1プロセスのみ起動）
   - 複数プロセス対応は将来の拡張として残す
   - 過剰設計を避け、実装コストとメンテナンスコストを削減

2. **ファイルロックの複雑性回避**
   - ファイルシステムの種類による挙動の違いを考慮する必要がない
   - ロック解放漏れ、デッドロックのリスクを排除
   - プロセスクラッシュ時の回復処理が不要

3. **現在の要件に適合**
   - スケジューラ（node-cron）が1時間ごとに1プロセスを起動
   - 前回の実行が完了してから次の実行が開始される設計
   - 意図的に複数プロセスを起動する運用フローがない

4. **将来の拡張余地**
   - 分散実行が必要になった場合、DynamoDBやRedisを導入可能
   - その時点で要件が明確になるため、適切な設計ができる
   - ファイルベースのスプールから外部ストレージへの移行も選択肢

5. **パフォーマンス**
   - ロック待機時間がゼロ（オーバーヘッドなし）
   - シンプルなファイル読み書きのみで高速動作

### トレードオフの受容

**受け入れるトレードオフ:**
- 水平スケールが制限される（1プロセスのみ）
  - **軽減策**: 現在の要件では1プロセスで十分、将来的に必要になれば外部ストレージを導入
  - **判断**: バッチサイズ100件、1時間ごとの実行で十分に処理可能

- 複数プロセス起動時にファイル競合のリスク
  - **軽減策**: スケジューラの設定で1プロセスのみ起動を保証、運用手順書に明記
  - **判断**: 設計上、複数プロセスは起動されない

- 将来的に分散実行が必要になった場合、大幅な再設計が必要
  - **軽減策**: ADRで決定事項を記録、将来の拡張方針を明記
  - **判断**: 現時点で不確実な要件に対して実装するのは過剰設計

## 影響

### ポジティブな影響

- **実装の簡素化**: ロック処理が不要、コードがシンプルになる
- **デバッグの容易さ**: 競合状態のトラブルシューティングが不要
- **パフォーマンス**: ロック待機時間ゼロ、高速動作
- **運用負荷の軽減**: ロック解放漏れ、デッドロックの監視が不要
- **外部依存なし**: ファイルシステムのみで完結

### ネガティブな影響

- **水平スケールの制限**: 1プロセスのみ、複数サーバーでの分散実行は不可
- **将来の拡張コスト**: 分散実行が必要になった場合、大幅な再設計が必要
- **運用リスク**: 誤って複数プロセスを起動した場合、ファイル競合が発生（運用手順書で対策）

### 中立的な影響

- **スケジューラの制約**: 1プロセスのみ起動する設定が必須
- **将来の拡張方針**: DynamoDBやRedisへの移行が選択肢として残る

## 実装への指針

### 原則

1. **スケジューラの設定**
   - node-cronの設定で、前回実行が完了してから次の実行を開始
   - 複数プロセスの同時起動を防止

2. **運用手順書への記載**
   - 単一プロセス前提であることを明記
   - 誤って複数プロセスを起動しないように注意喚起
   - 複数プロセス起動時の影響（ファイル競合）を説明

3. **ファイル操作の原子性**
   - ファイル書き込み時は一時ファイルを使用し、完了後にリネーム
   - 部分的な書き込みによる破損を防止

4. **将来の拡張余地**
   - スプールファイルの読み書きをSpoolManagerクラスに集約
   - 将来的にDynamoDBやRedisへ移行する際、インターフェースの変更のみで対応可能

5. **エラーハンドリング**
   - ファイル読み込み時の破損検出（zodバリデーション）
   - 破損ファイルは`data/failed/`へ移動

## 参考資料

- [YAGNI Principle (Martin Fowler)](https://martinfowler.com/bliki/Yagni.html) - 過剰設計の回避
- [Distributed Locks with Redis (Redis Documentation)](https://redis.io/docs/manual/patterns/distributed-locks/) - 将来の拡張オプション
- [DynamoDB Conditional Writes (AWS Documentation)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html#WorkingWithItems.ConditionalUpdate) - 将来の拡張オプション

## 関連情報

- Epic方針書: `specs/epics/1-dify-usage-exporter/epic.md`
- PRD: `specs/stories/4-external-api-sender/prd.md`
- 関連ADR:
  - ADR 001: スプールファイル形式（ファイル操作の対象）
  - ADR 006: スプール保持期間とリトライ上限（スプールファイルのライフサイクル）
