---
id: 9
feature: dify-usage-fetcher
type: adr
version: 1.0.0
created: 2025-11-21
based_on: specs/stories/2-dify-usage-fetcher/requirements.md
---

# ADR 009: Dify Usage Fetcherアーキテクチャ

## ステータス

Accepted

## コンテキスト

Dify Console APIから使用量データを定期的に取得し、外部システムへ連携するための「Dify Usage Fetcher」を設計する。この機能は以下の技術的課題に対応する必要がある：

1. **差分取得**: 毎回全データを取得するのではなく、前回からの差分のみを効率的に取得する必要がある
2. **API認証**: Dify Console APIへの認証方式を決定する必要がある
3. **大量データ処理**: 10,000件以上のレコードをメモリ効率よく処理する必要がある
4. **障害復旧**: ネットワーク障害やAPI一時停止から自動復旧する必要がある

### 制約条件

- **メモリ制限**: 100MB以内でのデータ処理
- **パフォーマンス**: 10,000件を30秒以内で取得
- **信頼性**: 99.9%以上の取得成功率
- **重複防止**: ウォーターマークによる完全な重複防止

## 決定事項

### 1. ウォーターマーク方式: ファイルベース

**ファイルベースのウォーターマーク管理を採用する。**

- **ファイルパス**: `data/watermark.json`
- **形式**:
  ```json
  {
    "last_fetched_date": "2025-01-15T00:00:00.000Z",
    "last_updated_at": "2025-01-16T02:00:00.000Z"
  }
  ```
- **更新タイミング**: 全ページ取得完了後に一括更新
- **バックアップ**: 更新前に `watermark.json.backup` を自動作成（1世代のみ）
- **復元機能**: 本ファイル破損時にバックアップから復元
- **ファイルパーミッション**: 600（所有者のみ読み書き）

### 2. Dify Console API認証: 固定Bearer Token方式

**固定Bearer Token方式（環境変数 `DIFY_API_TOKEN`）を採用する。**

- **認証ヘッダー**: `Authorization: Bearer ${DIFY_API_TOKEN}`
- **トークン管理**: 環境変数で事前設定、実行時のログイン不要
- **有効期限管理**: 不要（長期有効なAPIトークンを使用）

### 3. ページング処理: Offset-Based + 逐次処理

**Offset-Based Paginationと逐次処理を採用する。**

- **1ページあたり**: 100件（環境変数 `DIFY_FETCH_PAGE_SIZE` で変更可能）
- **取得方式**: `has_more: true` の間、次のページを取得
- **処理方式**: 各ページ取得後に即座に変換・送信（メモリ蓄積なし）
- **ページ間ディレイ**: 1秒（Rate Limit対策）

### 4. リトライ制御: 指数バックオフ（ADR 002準拠）

**指数バックオフ（固定係数）を採用する。**

- **最大リトライ回数**: 3回（環境変数 `DIFY_FETCH_RETRY_COUNT`）
- **バックオフ方式**: 指数バックオフ（1秒 → 2秒 → 4秒）
- **リトライ対象**: ネットワークエラー、5xx、429
- **リトライ非対象**: 400、401、403、404
- **429対応**: `Retry-After` ヘッダーを考慮

## 根拠

### 1. ウォーターマーク方式の選択肢

#### 案A: ファイルベース（採用）

- **説明**: JSONファイルでウォーターマーク位置を永続化
- **利点**:
  - 実装がシンプル（JSONの読み書きのみ）
  - 外部依存なし（データベース不要）
  - デバッグが容易（ファイルを直接確認可能）
  - バックアップ・復元が簡単
  - Epic共通の永続化方式と整合（スプールファイルと同様）
  - 自己修復型パイプライン: 障害後の次回実行で自動的に続行
- **欠点**:
  - 複数プロセス同時実行に非対応（ファイルロックが必要）
  - ファイルI/Oのオーバーヘッド
  - 原子性の保証が複雑

#### 案B: データベースベース（SQLite）

- **説明**: SQLiteデータベースでウォーターマークを管理
- **利点**:
  - トランザクションによる原子性保証
  - 複数プロセス対応可能
  - クエリによる柔軟な状態管理
  - 複数ウォーターマークの管理が容易
- **欠点**:
  - 外部依存の追加（SQLiteドライバー）
  - 実装が複雑（マイグレーション、コネクション管理）
  - オーバーエンジニアリング（単一プロセス・単一ウォーターマーク）
  - デバッグが困難（DBクライアントが必要）

#### 案C: メモリ内管理（永続化なし）

- **説明**: ウォーターマークをメモリに保持、プロセス終了で消失
- **利点**:
  - 実装が最もシンプル
  - I/Oオーバーヘッドなし
  - 外部依存なし
- **欠点**:
  - プロセス再起動で状態喪失（初期化から再取得）
  - 重複取得の防止不可
  - 本番環境で使用不可

#### 選択理由

**ファイルベースを選択した理由:**

1. **シンプルさ（最優先）**
   - 単一プロセス・単一ウォーターマークの要件に最適
   - JSONの読み書きのみで実装完了
   - 追加依存なし

2. **Epic共通方式との整合性**
   - スプールファイル（`data/spool/`）と同じファイルベース永続化
   - プロジェクト全体の一貫性を確保
   - コードレビュー・保守が容易

3. **運用性**
   - ファイルを直接確認可能（`cat data/watermark.json`）
   - バックアップによる自己修復
   - 手動リセットが容易（ファイル削除で初期状態）

4. **データ処理のベストプラクティス準拠**
   - ウォーターマークをデータと同じ永続化層で管理
   - 障害時の自己修復型パイプラインを実現

### 2. Dify Console API認証方式の選択肢

#### 案A: 固定Bearer Token方式（採用）

- **説明**: 環境変数 `DIFY_API_TOKEN` で事前設定したトークンを使用
- **利点**:
  - 実装がシンプル（ヘッダーにトークンを付加するのみ）
  - ログイン処理不要（認証エンドポイント呼び出しなし）
  - トークン有効期限管理不要（長期有効なAPIトークン）
  - セキュリティリスク低（email/password未使用）
  - パフォーマンス向上（認証往復なし）
- **欠点**:
  - トークンの手動発行・設定が必要
  - トークン漏洩時のリスク（環境変数管理で軽減）
  - Dify側でAPIトークン発行が必要（事前作業）

#### 案B: email/password方式

- **説明**: 実行時に `/console/api/login` でログインしてトークン取得
- **利点**:
  - トークンの事前発行が不要
  - 常に最新のトークンを使用
  - Difyコンソールの既存ユーザーで利用可能
- **欠点**:
  - 実装が複雑（ログインエンドポイント呼び出し、レスポンス解析）
  - email/passwordを環境変数に保存（セキュリティリスク高）
  - トークン有効期限管理が必要（refresh_token対応）
  - 毎回ログインのオーバーヘッド
  - ログイン失敗時のハンドリングが複雑

#### 案C: OAuth認証方式

- **説明**: GitHub/Google OAuth経由で認証
- **利点**:
  - 標準的なOAuth2.0フロー
  - パスワードレス認証
  - サードパーティ認証プロバイダーの信頼性
- **欠点**:
  - 実装が最も複雑（OAuth フロー全体の実装）
  - 自動化困難（対話式認証が必要）
  - バッチ処理に不向き
  - 過剰設計（本用途には過剰）

#### 選択理由

**固定Bearer Token方式を選択した理由:**

1. **セキュリティリスク低減（最優先）**
   - email/passwordを環境変数に保存しない
   - トークン漏洩リスクは環境変数管理で軽減可能
   - Dify APIキー方式と整合（`Bearer app-XXXXX` 形式）

2. **実装シンプル**
   - ログイン処理不要
   - トークン有効期限管理不要
   - エラーハンドリングが単純（認証失敗 = 401のみ）

3. **パフォーマンス**
   - 認証往復なしで即座にデータ取得開始
   - 全体処理時間の短縮

4. **運用性**
   - Difyコンソールでトークンを一度発行すれば継続利用
   - トークンローテーション時も環境変数変更のみ

### 3. ページング処理アーキテクチャの選択肢

#### 案A: Offset-Based + 逐次処理（採用）

- **説明**: Offset-Based Paginationで逐次取得、各ページを即座に処理
- **利点**:
  - メモリ使用量を最小化（1ページ分のみ保持）
  - 実装がシンプル（ページ番号のインクリメント）
  - 途中失敗時に取得済みデータは処理済み
  - Dify APIの想定インターフェースと整合
  - デバッグが容易（任意のページを直接取得可能）
- **欠点**:
  - 大量オフセットで性能劣化（10,000件超では影響軽微）
  - データ変更時に重複・欠落のリスク（ウォーターマークで軽減）

#### 案B: Cursor-Based + 逐次処理

- **説明**: Cursor-Based Paginationで逐次取得
- **利点**:
  - 大量データでも安定した性能
  - データ変更時の整合性が高い
  - 業界標準のベストプラクティス
- **欠点**:
  - Dify APIがCursor-Basedをサポートするか不明
  - 実装が複雑（カーソル管理）
  - 任意ページへの直接アクセス不可

#### 案C: 全ページ取得後バッチ処理

- **説明**: 全ページをメモリに蓄積後、一括処理
- **利点**:
  - トランザクション的な整合性（全成功 or 全失敗）
  - データ変換の最適化が可能
  - 重複排除が容易
- **欠点**:
  - メモリ使用量が大きい（全データを保持）
  - 100MB制限違反のリスク
  - 途中失敗時に全データ喪失
  - メモリ不足によるクラッシュリスク

#### 選択理由

**Offset-Based + 逐次処理を選択した理由:**

1. **メモリ効率（最優先）**
   - 100MB制限を確実に遵守
   - 1ページ（100件）分のみメモリ保持
   - 10,000件でも安定動作

2. **Dify APIとの整合性**
   - 要件定義のAPIレスポンス形式がOffset-Based前提
   - `page`, `limit`, `has_more` パラメータ
   - Cursor-Based対応が不明確

3. **途中失敗時の復旧**
   - 取得・処理済みデータはウォーターマーク更新で保護
   - 次回実行で続きから取得
   - 自己修復型パイプライン

4. **性能トレードオフの許容**
   - 10,000件程度ではOffset性能劣化は軽微
   - ページ間1秒ディレイがあるため、クエリ時間は相対的に小さい

### 4. リトライ制御の選択肢

#### 案A: 指数バックオフ（固定係数）（採用）

- **説明**: リトライ間隔を指数的に増加（1秒 → 2秒 → 4秒）
- **利点**:
  - サーバー負荷を分散
  - Rate Limit（429）に効果的
  - ADR 002（外部API送信）と統一
  - 業界標準アプローチ
  - axios-retryで標準サポート
- **欠点**:
  - 総待機時間が長い（最大7秒）
  - 短時間復旧エラーには過剰

#### 案B: 線形バックオフ（固定間隔）

- **説明**: 固定間隔でリトライ（1秒間隔で3回）
- **利点**:
  - 実装が最もシンプル
  - 予測可能な挙動（総待機時間3秒）
  - 短時間復旧エラーに効果的
- **欠点**:
  - サーバー負荷が分散されない
  - Rate Limit対応不十分
  - ADR 002との不整合

#### 案C: 指数バックオフ（ジッター付き）

- **説明**: 指数バックオフにランダムジッターを追加
- **利点**:
  - Thundering Herd問題を完全回避
  - サーバー負荷を最大限に分散
  - AWS公式推奨
- **欠点**:
  - 実装が複雑
  - 予測不可能な挙動（デバッグ困難）
  - 単一プロセスではオーバーエンジニアリング

#### 選択理由

**指数バックオフ（固定係数）を選択した理由:**

1. **Epic全体の一貫性（最優先）**
   - ADR 002（リトライポリシー）で確定済み
   - ADR 007（HTTPクライアント）でaxios-retry採用済み
   - 全ストーリーで同じリトライ戦略

2. **Rate Limit対応**
   - Dify APIのRate Limitが不明
   - 待機時間増加でRate Limitウィンドウをリセット

3. **実装済みインフラ活用**
   - axios-retryの `exponentialDelay` 関数
   - 追加実装不要

4. **429エラー時の特別対応**
   - `Retry-After` ヘッダーを考慮
   - ヘッダー値が指定されていれば、それに従う

## 影響

### ポジティブな影響

- **メモリ効率**: 逐次処理により100MB制限を確実に遵守
- **信頼性**: ウォーターマーク + リトライで99.9%の取得成功率達成
- **運用性**: ファイルベースで状態確認・手動リセットが容易
- **保守性**: Epic共通方式との整合で、コードレビュー・保守が容易
- **セキュリティ**: 固定Bearer Tokenでemail/password不使用

### ネガティブな影響

- **トークン管理**: Difyコンソールで事前にAPIトークン発行が必要
- **並行処理不可**: ファイルベースウォーターマークは単一プロセス前提
- **Offset性能**: 非常に大量のデータ（100,000件超）では性能劣化の可能性

### 中立的な影響

- **ログ出力増加**: 各ページ取得、リトライ試行のログが追加
- **設定項目**: 環境変数が増加（`DIFY_API_TOKEN`, `DIFY_FETCH_PAGE_SIZE`等）

## 比較マトリクス

### ウォーターマーク方式

| 評価軸 | ファイルベース | データベース | メモリ内 |
|--------|--------------|------------|---------|
| 実装難易度 | **低** | 中 | **低** |
| 外部依存 | **なし** | SQLite | **なし** |
| 原子性 | 低 | **高** | - |
| 複数プロセス | 不可 | **可** | 不可 |
| デバッグ容易性 | **高** | 低 | - |
| 推奨 | **採用** | 将来検討 | 不採用 |

### 認証方式

| 評価軸 | 固定Bearer Token | email/password | OAuth |
|--------|-----------------|----------------|-------|
| 実装難易度 | **低** | 中 | 高 |
| セキュリティリスク | **低** | 中 | 低 |
| パフォーマンス | **高** | 低 | 低 |
| 運用負荷 | **低** | 中 | 高 |
| 推奨 | **採用** | 保留 | 不採用 |

### ページング処理

| 評価軸 | Offset + 逐次 | Cursor + 逐次 | 全取得バッチ |
|--------|-------------|-------------|------------|
| メモリ効率 | **高** | **高** | 低 |
| 実装難易度 | **低** | 中 | 低 |
| 大量データ性能 | 中 | **高** | 低 |
| API互換性 | **高** | 不明 | **高** |
| 推奨 | **採用** | API対応次第 | 不採用 |

### リトライ制御

| 評価軸 | 指数バックオフ | 線形バックオフ | ジッター付き |
|--------|-------------|-------------|------------|
| サーバー負荷分散 | **高** | 低 | **高** |
| Rate Limit対応 | **高** | 低 | **高** |
| 実装難易度 | **低** | **低** | 中 |
| Epic一貫性 | **高** | 低 | 中 |
| 推奨 | **採用** | 不採用 | 将来検討 |

## 実装への指針

### 原則

#### 1. ウォーターマーク管理

- **読み込み**: アプリケーション起動時に `watermark.json` を読み込み
- **ファイル不存在時**: 初回実行と判断、過去30日間を取得
- **書き込み**: 全ページ取得完了後に一括更新
- **バックアップ**: 書き込み前に `.backup` を作成
- **復元**: 本ファイル破損時にバックアップから自動復元

#### 2. Dify API認証

- **環境変数**: `DIFY_API_TOKEN` で固定Bearer Tokenを設定
- **ヘッダー設定**: axiosインスタンス作成時に `Authorization` ヘッダーを設定
- **401エラー**: ログ出力後、処理終了（トークン再設定が必要）

#### 3. ページング処理

- **ループ構造**: `while (hasMore)` でページ取得を繰り返し
- **即時処理**: 各ページ取得後、即座にTransformer → Senderへ渡す
- **ディレイ**: 各ページ取得後に1秒待機（Rate Limit対策）
- **進捗ログ**: 100ページごとに進捗状況を出力

#### 4. リトライ制御

- **axios-retry設定**: ADR 007の実装指針に従う
- **リトライ条件**: `isNetworkOrIdempotentRequestError` + 5xx + 429
- **429特別対応**: `Retry-After` ヘッダー値があれば、それに従う
- **ログ出力**: 各リトライ試行時にエラー内容とバックオフ時間を記録

#### 5. エラーハンドリング

- **ページ取得失敗時**: 取得済みデータまでウォーターマーク更新
- **バリデーションエラー**: 該当レコードをスキップ、処理継続
- **同一エラー3回連続**: 処理中断、エラー通知（Story 5）

### 環境変数

| 環境変数名 | 必須 | デフォルト | 説明 |
|-----------|------|-----------|------|
| `DIFY_API_BASE_URL` | Yes | - | Dify Console APIのベースURL |
| `DIFY_API_TOKEN` | Yes | - | 固定Bearer Token |
| `DIFY_FETCH_PAGE_SIZE` | No | 100 | 1ページあたりの取得件数 |
| `DIFY_INITIAL_FETCH_DAYS` | No | 30 | 初回実行時の取得期間（日数） |
| `DIFY_FETCH_TIMEOUT_MS` | No | 30000 | APIタイムアウト（ミリ秒） |
| `DIFY_FETCH_RETRY_COUNT` | No | 3 | 最大リトライ回数 |
| `DIFY_FETCH_RETRY_DELAY_MS` | No | 1000 | 初回リトライディレイ（ミリ秒） |
| `WATERMARK_FILE_PATH` | No | data/watermark.json | ウォーターマークファイルパス |

## 参考資料

### ウォーターマーク・差分取得

- [Incremental Load Strategy for Data Warehouses (2025)](https://blog.skyvia.com/incremental-load-strategy-for-data-warehouses/) - ウォーターマーク方式のベストプラクティス
- [Robust data ingestion with High-watermarking - Microsoft Tech Community](https://techcommunity.microsoft.com/blog/fasttrackforazureblog/robust-data-ingestion-with-high-watermarking/3707480) - 高ウォーターマークによるデータ取り込み
- [Incremental Processing with Apache Iceberg & Spark](https://medium.com/@amitgil87/incremental-processing-with-apache-iceberg-spark-a-comprehensive-guide-ef2deaabe1f7) - 原子的なウォーターマーク更新

### リトライ・バックオフ

- [Retry with backoff pattern - AWS Prescriptive Guidance](https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/retry-backoff.html) - AWSリトライパターンガイド
- [Timeouts, retries and backoff with jitter - AWS Builders' Library](https://aws.amazon.com/builders-library/timeouts-retries-and-backoff-with-jitter/) - ジッター付きバックオフの詳細
- [Mastering Exponential Backoff in Distributed Systems - Better Stack](https://betterstack.com/community/guides/monitoring/exponential-backoff/) - 指数バックオフの実装例

### ページング

- [Understanding Cursor Pagination and Why It's So Fast (Deep Dive)](https://www.milanjovanovic.tech/blog/understanding-cursor-pagination-and-why-its-so-fast-deep-dive) - Cursor vs Offsetの性能比較
- [Mastering API Pagination: Best Practices for Performance & Scalability](https://medium.com/@khanshahid9283/mastering-api-pagination-best-practices-for-performance-scalability-ca16980bc8f0) - APIページングのベストプラクティス

### Dify API

- [Dify API Access Documentation](https://docs.dify.ai/en/openapi-api-access-readme) - Dify公式APIドキュメント
- [Dify Console API Discussion](https://github.com/langgenius/dify/discussions/9237) - Console API認証に関するディスカッション

## 関連情報

- Epic方針書: `specs/epics/1-dify-usage-exporter/epic.md`
- 要件定義書: `specs/stories/2-dify-usage-fetcher/requirements.md`
- 関連ADR:
  - ADR 002: リトライポリシー（指数バックオフの詳細）
  - ADR 003: ファイルロック機構（ウォーターマークファイルの排他制御）
  - ADR 007: HTTPクライアントライブラリ（axios + axios-retry）
